//
//  CircularProgressCombined.swift
//  Treat Yourself Circular Progress
//
//  Created by Victoria Melendez on 12/1/16.
//  Copyright Â© 2016 CompanyName. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//
//  This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
//



import UIKit

public class CircularProgressCombined : NSObject {

    //// Drawing Methods

    public dynamic class func drawCanvas1(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 156, height: 195), resizing: ResizingBehavior = .aspectFit, progressDash: CGFloat = 180, velocityDash: CGFloat = 215, daysDash: CGFloat = 161) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 156, height: 195), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 156, y: resizedFrame.height / 195)


        //// Color Declarations
        let themeDarkGreen = UIColor(red: 0.000, green: 0.475, blue: 0.420, alpha: 1.000)
        let themeGold = UIColor(red: 1.000, green: 0.757, blue: 0.027, alpha: 1.000)
        let gradient3Color = UIColor(red: 0.163, green: 0.148, blue: 0.148, alpha: 1.000)
        let cremeColor = UIColor(red: 0.974, green: 0.968, blue: 0.821, alpha: 1.000)

        //// Gradient Declarations
        let gradient = CGGradient(colorsSpace: nil, colors: [themeGold.cgColor, themeGold.blended(withFraction: 0.5, of: cremeColor).cgColor, cremeColor.cgColor] as CFArray, locations: [0, 1, 1])!
        let gradient2 = CGGradient(colorsSpace: nil, colors: [themeDarkGreen.cgColor, themeDarkGreen.blended(withFraction: 0.5, of: cremeColor).cgColor, cremeColor.cgColor] as CFArray, locations: [0, 1, 1])!
        let gradient3 = CGGradient(colorsSpace: nil, colors: [gradient3Color.cgColor, gradient3Color.blended(withFraction: 0.5, of: cremeColor).cgColor, cremeColor.cgColor] as CFArray, locations: [0, 1, 1])!

        //// ColorGroup
        //// ProgressOval Drawing
        let progressOvalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 26, width: 148, height: 148))
        context.saveGState()
        progressOvalPath.addClip()
        context.drawLinearGradient(gradient, start: CGPoint(x: 78, y: 26), end: CGPoint(x: 78, y: 174), options: [])
        context.restoreGState()


        //// VelocityOval Drawing
        let velocityOvalPath = UIBezierPath(ovalIn: CGRect(x: 22, y: 44, width: 112, height: 112))
        context.saveGState()
        velocityOvalPath.addClip()
        context.drawLinearGradient(gradient2, start: CGPoint(x: 78, y: 156), end: CGPoint(x: 78, y: 44), options: [])
        context.restoreGState()
        UIColor.white.setStroke()
        velocityOvalPath.lineWidth = 2
        velocityOvalPath.stroke()


        //// DaysOval Drawing
        let daysOvalPath = UIBezierPath(ovalIn: CGRect(x: 40, y: 62, width: 76, height: 76))
        context.saveGState()
        daysOvalPath.addClip()
        context.drawLinearGradient(gradient3, start: CGPoint(x: 78, y: 138), end: CGPoint(x: 78, y: 62), options: [])
        context.restoreGState()
        UIColor.white.setStroke()
        daysOvalPath.lineWidth = 2
        daysOvalPath.stroke()




        //// MaskGroup
        context.saveGState()
        context.translateBy(x: 78, y: 100)
        context.rotate(by: 322.44 * CGFloat.pi/180)

        context.setBlendMode(.overlay)
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// ProgressMask Drawing
        context.saveGState()
        context.rotate(by: 20.89 * CGFloat.pi/180)

        context.saveGState()
        context.setAlpha(0.8)

        let progressMaskPath = UIBezierPath()
        progressMaskPath.move(to: CGPoint(x: 19.25, y: -62.28))
        progressMaskPath.addCurve(to: CGPoint(x: 33.58, y: -56.31), controlPoint1: CGPoint(x: 23.53, y: -61.45), controlPoint2: CGPoint(x: 28.76, y: -59.36))
        progressMaskPath.addCurve(to: CGPoint(x: 40.72, y: -50.82), controlPoint1: CGPoint(x: 36.19, y: -54.66), controlPoint2: CGPoint(x: 39.14, y: -51.8))
        progressMaskPath.addCurve(to: CGPoint(x: 40.75, y: -50.99), controlPoint1: CGPoint(x: 42.85, y: -49.51), controlPoint2: CGPoint(x: 38.79, y: -52.53))
        progressMaskPath.addCurve(to: CGPoint(x: 59.81, y: -26.58), controlPoint1: CGPoint(x: 48.91, y: -44.54), controlPoint2: CGPoint(x: 55.49, y: -36.18))
        progressMaskPath.addCurve(to: CGPoint(x: 65.51, y: 0.06), controlPoint1: CGPoint(x: 63.47, y: -18.45), controlPoint2: CGPoint(x: 65.51, y: -9.43))
        progressMaskPath.addCurve(to: CGPoint(x: 63.7, y: 15.36), controlPoint1: CGPoint(x: 65.51, y: 5.33), controlPoint2: CGPoint(x: 64.88, y: 10.45))
        progressMaskPath.addCurve(to: CGPoint(x: 0.51, y: 65.06), controlPoint1: CGPoint(x: 56.82, y: 43.88), controlPoint2: CGPoint(x: 31.14, y: 65.06))
        progressMaskPath.addCurve(to: CGPoint(x: -64.49, y: 0.06), controlPoint1: CGPoint(x: -35.39, y: 65.06), controlPoint2: CGPoint(x: -64.49, y: 35.96))
        progressMaskPath.addCurve(to: CGPoint(x: 0.51, y: -64.94), controlPoint1: CGPoint(x: -64.49, y: -35.83), controlPoint2: CGPoint(x: -35.39, y: -64.94))
        progressMaskPath.addCurve(to: CGPoint(x: 19.25, y: -62.28), controlPoint1: CGPoint(x: 7.33, y: -64.94), controlPoint2: CGPoint(x: 11.34, y: -63.82))
        progressMaskPath.close()
        UIColor.white.setStroke()
        progressMaskPath.lineWidth = 17
        context.saveGState()
        context.setLineDash(phase: 0, lengths: [progressDash, 408])
        progressMaskPath.stroke()
        context.restoreGState()

        context.restoreGState()

        context.restoreGState()


        //// VelocityMask Drawing
        context.saveGState()
        context.rotate(by: 1.96 * CGFloat.pi/180)

        context.saveGState()
        context.setAlpha(0.5)

        let velocityMaskPath = UIBezierPath()
        velocityMaskPath.move(to: CGPoint(x: 27.52, y: -38.1))
        velocityMaskPath.addCurve(to: CGPoint(x: 47, y: 0), controlPoint1: CGPoint(x: 39.32, y: -29.56), controlPoint2: CGPoint(x: 47, y: -15.68))
        velocityMaskPath.addCurve(to: CGPoint(x: -0, y: 47), controlPoint1: CGPoint(x: 47, y: 25.96), controlPoint2: CGPoint(x: 25.96, y: 47))
        velocityMaskPath.addCurve(to: CGPoint(x: -47, y: 0), controlPoint1: CGPoint(x: -25.96, y: 47), controlPoint2: CGPoint(x: -47, y: 25.96))
        velocityMaskPath.addCurve(to: CGPoint(x: 0, y: -47), controlPoint1: CGPoint(x: -47, y: -25.96), controlPoint2: CGPoint(x: -25.96, y: -47))
        velocityMaskPath.addCurve(to: CGPoint(x: 27.52, y: -38.1), controlPoint1: CGPoint(x: 10.28, y: -47), controlPoint2: CGPoint(x: 19.79, y: -43.7))
        velocityMaskPath.close()
        UIColor.white.setStroke()
        velocityMaskPath.lineWidth = 17
        context.saveGState()
        context.setLineDash(phase: 0, lengths: [velocityDash, 295])
        velocityMaskPath.stroke()
        context.restoreGState()

        context.restoreGState()

        context.restoreGState()


        //// DaysMask Drawing
        context.saveGState()

        context.saveGState()
        context.setAlpha(0.5)

        let daysMaskPath = UIBezierPath()
        daysMaskPath.move(to: CGPoint(x: 17.98, y: -22.75))
        daysMaskPath.addCurve(to: CGPoint(x: 29, y: 0), controlPoint1: CGPoint(x: 24.69, y: -17.44), controlPoint2: CGPoint(x: 29, y: -9.22))
        daysMaskPath.addCurve(to: CGPoint(x: 24.51, y: 15.51), controlPoint1: CGPoint(x: 29, y: 5.7), controlPoint2: CGPoint(x: 27.35, y: 11.02))
        daysMaskPath.addCurve(to: CGPoint(x: 0, y: 29), controlPoint1: CGPoint(x: 19.37, y: 23.62), controlPoint2: CGPoint(x: 10.31, y: 29))
        daysMaskPath.addCurve(to: CGPoint(x: -29, y: 0), controlPoint1: CGPoint(x: -16.02, y: 29), controlPoint2: CGPoint(x: -29, y: 16.02))
        daysMaskPath.addCurve(to: CGPoint(x: 0, y: -29), controlPoint1: CGPoint(x: -29, y: -16.02), controlPoint2: CGPoint(x: -16.02, y: -29))
        daysMaskPath.addCurve(to: CGPoint(x: 17.98, y: -22.75), controlPoint1: CGPoint(x: 6.79, y: -29), controlPoint2: CGPoint(x: 13.04, y: -26.66))
        daysMaskPath.close()
        UIColor.white.setStroke()
        daysMaskPath.lineWidth = 17
        context.saveGState()
        context.setLineDash(phase: 0, lengths: [daysDash, 182])
        daysMaskPath.stroke()
        context.restoreGState()

        context.restoreGState()

        context.restoreGState()


        context.endTransparencyLayer()

        context.restoreGState()
        
        context.restoreGState()

    }

    public dynamic class func drawProgressVelocityCompilation(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 156, height: 195), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 156, height: 195), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 156, y: resizedFrame.height / 195)


        //// Color Declarations
        let themeDarkGreen = UIColor(red: 0.000, green: 0.475, blue: 0.420, alpha: 1.000)
        var themeDarkGreenHueComponent: CGFloat = 1
        var themeDarkGreenSaturationComponent: CGFloat = 1
        var themeDarkGreenBrightnessComponent: CGFloat = 1
        themeDarkGreen.getHue(&themeDarkGreenHueComponent, saturation: &themeDarkGreenSaturationComponent, brightness: &themeDarkGreenBrightnessComponent, alpha: nil)

        let darkGreenBkg = UIColor(hue: themeDarkGreenHueComponent, saturation: themeDarkGreenSaturationComponent, brightness: 0.8, alpha: themeDarkGreen.cgColor.alpha)
        let themeGold = UIColor(red: 1.000, green: 0.757, blue: 0.027, alpha: 1.000)
        var themeGoldRedComponent: CGFloat = 1
        var themeGoldGreenComponent: CGFloat = 1
        var themeGoldBlueComponent: CGFloat = 1
        themeGold.getRed(&themeGoldRedComponent, green: &themeGoldGreenComponent, blue: &themeGoldBlueComponent, alpha: nil)

        let goldBkg = UIColor(red: (themeGoldRedComponent * 0.3 + 0.7), green: (themeGoldGreenComponent * 0.3 + 0.7), blue: (themeGoldBlueComponent * 0.3 + 0.7), alpha: (themeGold.cgColor.alpha * 0.3 + 0.7))
        let gradient3Color = UIColor(red: 0.163, green: 0.148, blue: 0.148, alpha: 1.000)
        var gradient3ColorHueComponent: CGFloat = 1
        var gradient3ColorSaturationComponent: CGFloat = 1
        var gradient3ColorBrightnessComponent: CGFloat = 1
        gradient3Color.getHue(&gradient3ColorHueComponent, saturation: &gradient3ColorSaturationComponent, brightness: &gradient3ColorBrightnessComponent, alpha: nil)

        let darkBkg = UIColor(hue: gradient3ColorHueComponent, saturation: gradient3ColorSaturationComponent, brightness: 0.7, alpha: gradient3Color.cgColor.alpha)

        //// ColorGroup
        //// ProgressOval Drawing
        let progressOvalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 26, width: 148, height: 148))
        goldBkg.setFill()
        progressOvalPath.fill()


        //// VelocityOval Drawing
        let velocityOvalPath = UIBezierPath(ovalIn: CGRect(x: 22, y: 44, width: 112, height: 112))
        darkGreenBkg.setFill()
        velocityOvalPath.fill()
        UIColor.white.setStroke()
        velocityOvalPath.lineWidth = 2
        velocityOvalPath.stroke()


        //// DaysOval Drawing
        let daysOvalPath = UIBezierPath(ovalIn: CGRect(x: 40, y: 62, width: 76, height: 76))
        darkBkg.setFill()
        daysOvalPath.fill()
        UIColor.white.setStroke()
        daysOvalPath.lineWidth = 2
        daysOvalPath.stroke()




        //// SymbolGroup
        context.saveGState()
        context.setBlendMode(.sourceAtop)
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Symbol Drawing
        let symbolRect = CGRect(x: 0, y: 0, width: 156, height: 195)
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        CircularProgressCombined.drawCanvas1(frame: CGRect(origin: .zero, size: symbolRect.size), resizing: .stretch, progressDash: 12, velocityDash: 10, daysDash: 8)
        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 58, y: 80, width: 41, height: 41))
        UIColor.white.setFill()
        ovalPath.fill()


        //// ProgressArrow
        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: 85.5, y: 35.5))
        bezier3Path.addCurve(to: CGPoint(x: 83.5, y: 37.5), controlPoint1: CGPoint(x: 83.5, y: 37.5), controlPoint2: CGPoint(x: 83.5, y: 37.5))
        UIColor.black.setStroke()
        bezier3Path.lineWidth = 1
        bezier3Path.lineCapStyle = .round
        bezier3Path.stroke()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 85.5, y: 35.5))
        bezierPath.addCurve(to: CGPoint(x: 80.5, y: 35.5), controlPoint1: CGPoint(x: 81.5, y: 35.5), controlPoint2: CGPoint(x: 80.5, y: 35.5))
        UIColor.black.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.lineCapStyle = .round
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: 83.5, y: 33.5))
        bezier2Path.addCurve(to: CGPoint(x: 85.5, y: 35.5), controlPoint1: CGPoint(x: 85.5, y: 35.5), controlPoint2: CGPoint(x: 85.5, y: 35.5))
        bezier2Path.addLine(to: CGPoint(x: 85.5, y: 35.5))
        UIColor.black.setStroke()
        bezier2Path.lineWidth = 1
        bezier2Path.lineCapStyle = .round
        bezier2Path.stroke()




        //// VelocityArrow
        //// Bezier 4 Drawing
        let bezier4Path = UIBezierPath()
        bezier4Path.move(to: CGPoint(x: 84.5, y: 53.5))
        bezier4Path.addCurve(to: CGPoint(x: 82.5, y: 55.5), controlPoint1: CGPoint(x: 82.5, y: 55.5), controlPoint2: CGPoint(x: 82.5, y: 55.5))
        UIColor.black.setStroke()
        bezier4Path.lineWidth = 1
        bezier4Path.lineCapStyle = .round
        bezier4Path.stroke()


        //// Bezier 5 Drawing
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: 84.5, y: 53.5))
        bezier5Path.addCurve(to: CGPoint(x: 79.5, y: 53.5), controlPoint1: CGPoint(x: 80.5, y: 53.5), controlPoint2: CGPoint(x: 79.5, y: 53.5))
        UIColor.black.setStroke()
        bezier5Path.lineWidth = 1
        bezier5Path.lineCapStyle = .round
        bezier5Path.stroke()


        //// Bezier 6 Drawing
        let bezier6Path = UIBezierPath()
        bezier6Path.move(to: CGPoint(x: 82.5, y: 51.5))
        bezier6Path.addCurve(to: CGPoint(x: 84.5, y: 53.5), controlPoint1: CGPoint(x: 84.5, y: 53.5), controlPoint2: CGPoint(x: 84.5, y: 53.5))
        bezier6Path.addLine(to: CGPoint(x: 84.5, y: 53.5))
        UIColor.black.setStroke()
        bezier6Path.lineWidth = 1
        bezier6Path.lineCapStyle = .round
        bezier6Path.stroke()




        //// DaysArrow
        //// Bezier 7 Drawing
        let bezier7Path = UIBezierPath()
        bezier7Path.move(to: CGPoint(x: 84.5, y: 71.5))
        bezier7Path.addCurve(to: CGPoint(x: 82.5, y: 73.5), controlPoint1: CGPoint(x: 82.5, y: 73.5), controlPoint2: CGPoint(x: 82.5, y: 73.5))
        UIColor.black.setStroke()
        bezier7Path.lineWidth = 1
        bezier7Path.lineCapStyle = .round
        bezier7Path.stroke()


        //// Bezier 8 Drawing
        let bezier8Path = UIBezierPath()
        bezier8Path.move(to: CGPoint(x: 84.5, y: 71.5))
        bezier8Path.addCurve(to: CGPoint(x: 79.5, y: 71.5), controlPoint1: CGPoint(x: 80.5, y: 71.5), controlPoint2: CGPoint(x: 79.5, y: 71.5))
        UIColor.black.setStroke()
        bezier8Path.lineWidth = 1
        bezier8Path.lineCapStyle = .round
        bezier8Path.stroke()


        //// Bezier 9 Drawing
        let bezier9Path = UIBezierPath()
        bezier9Path.move(to: CGPoint(x: 82.5, y: 69.5))
        bezier9Path.addCurve(to: CGPoint(x: 84.5, y: 71.5), controlPoint1: CGPoint(x: 84.5, y: 71.5), controlPoint2: CGPoint(x: 84.5, y: 71.5))
        bezier9Path.addLine(to: CGPoint(x: 84.5, y: 71.5))
        UIColor.black.setStroke()
        bezier9Path.lineWidth = 1
        bezier9Path.lineCapStyle = .round
        bezier9Path.stroke()
        
        context.restoreGState()

    }




    @objc public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



extension UIColor {
    func blended(withFraction fraction: CGFloat, of color: UIColor) -> UIColor {
        var r1: CGFloat = 1, g1: CGFloat = 1, b1: CGFloat = 1, a1: CGFloat = 1
        var r2: CGFloat = 1, g2: CGFloat = 1, b2: CGFloat = 1, a2: CGFloat = 1

        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
            green: g1 * (1 - fraction) + g2 * fraction,
            blue: b1 * (1 - fraction) + b2 * fraction,
            alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}
